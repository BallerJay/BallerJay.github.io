<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>JavaScript - Category - Summer&#39;s Blog</title>
        <link>https://ballerjay.github.io/categories/javascript/</link>
        <description>JavaScript - Category - Summer&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 19 May 2022 19:05:49 &#43;0800</lastBuildDate><atom:link href="https://ballerjay.github.io/categories/javascript/" rel="self" type="application/rss+xml" /><item>
    <title>总结 ES2015 的所有新特性</title>
    <link>https://ballerjay.github.io/posts/es2015/</link>
    <pubDate>Thu, 19 May 2022 19:05:49 &#43;0800</pubDate>
    <author>Summer</author>
    <guid>https://ballerjay.github.io/posts/es2015/</guid>
    <description><![CDATA[总结 ES2015 的所有新特性 💥 ES2015(ES6)是改动最大的一个版本，大体如下: 🍏 let、const关键字和块级作用域 在ES6来临之前，我们习惯于var 关键字声明变量，var声明的变量是属于全局变量，最终会挂载到window对象，这一操作可能会引起一些意外的错误。所以在ES6中加入了const和let	关键字来声明变量。
let v = 100 v = 200 const a = 1 a = 2; // Uncaught TypeError: Assignment to constant variable. // 报错，const关键字声明的是一个常量，是不可以改变的（针对于基本数据类型） { var a = 100 } { let b = 100 } console.log(a) // output: 100 console.log(b) // 报错，b is not defined. // let声明的变量只能在当前的`块级作用域({} 之间的区域)`中使用 ⚠️ let、const声明的变量存在一个暂时性死区的问题
a = 1; let a = 0;// Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization // 暂时性死区是指使用let、const关键字声明的变量在定义之前是不可以使用的，声明之后才可以使用。 🍐 函数的扩展（函数形参的默认值、箭头函数）   函数默认值]]></description>
</item>
</channel>
</rss>
